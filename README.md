Шаблон Iterator дозволяє клієнтам ефективно циклічно переглядати колекцію об'єктів.

Поширеною завданням програмування є обхід і маніпулювання набором об'єктів. Ці колекції можуть зберігатися у вигляді масиву або, можливо, чогось більш складного, наприклад, дерева або графової структури. Крім того, вам може знадобитися отримати доступ до елементів колекції в певному порядку, таких як, спереду назад, ззаду наперед, спочатку глибина (як у пошуку дерев), пропустити рівномірно пронумеровані об'єкти тощо.

Шаблон проектування Iterator вирішує цю проблему шляхом відділення колекції об'єктів від обходу цих об'єктів шляхом реалізації спеціалізованого ітератора.

Сьогодні багато мов мають вбудовані ітератори, підтримуючи конструкції типу "для кожної", а також інтерфейси IEnumerable та IEnumerator. Однак JavaScript підтримує лише базове циклічне циклювання у вигляді операторів for, for-in, while та do while.

Шаблон Iterator дозволяє розробникам JavaScript розробляти циклічні конструкції, які є набагато гнучкішими та досконалішими.

![image](https://user-images.githubusercontent.com/46648541/227898993-d2642bf2-5265-4405-a33f-1650f07cbcc1.png)


Учасники
#
Об'єктами, що беруть участь в цій закономірності, є:

Клієнт -- У прикладі коду: функція run()
посилається та викликає ітератор з набором об'єктів

Ітератор -- У прикладі коду: Iterator
реалізує інтерфейс ітератора з методами first(), next() і т.д.
стежить за поточним положенням при обході збору

Елементи -- У прикладі коду: Елементи
окремі об'єкти колекції, що перетинаються

Об'єкт Iterator зберігає посилання на колекцію та поточне положення. Він також реалізує «стандартний» інтерфейс Iterator з такими методами, як: перший, наступний, маєNext, скидання та кожен.

Використовуються два методи циклу: вбудований для циклу і новостворений кожен метод. For loop використовує перший, маєнаступний, і наступний методи для управління ітерацією. Кожен метод робить внутрішньо абсолютно однаковий (тобто запускає цикл for loop), але для клієнта синтаксис був значно спрощений.

var Iterator = function (items) {
    this.index = 0;
    this.items = items;
}

Iterator.prototype = {
    first: function () {
        this.reset();
        return this.next();
    },
    next: function () {
        return this.items[this.index++];
    },
    hasNext: function () {
        return this.index <= this.items.length;
    },
    reset: function () {
        this.index = 0;
    },
    each: function (callback) {
        for (var item = this.first(); this.hasNext(); item = this.next()) {
            callback(item);
        }
    }
}

function run() {

    var items = ["one", 2, "circle", true, "Applepie"];
    var iter = new Iterator(items);

    // using for loop

    for (var item = iter.first(); iter.hasNext(); item = iter.next()) {
        console.log(item);
    }
    console.log("");

    // using Iterator's each method

    iter.each(function (item) {
        console.log(item);
    });
}
